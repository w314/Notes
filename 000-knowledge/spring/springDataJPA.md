
spring, java, spring data, spring data jpa


# Spring Data JPA (Java Persistence API)  

facilitates communicaiton with our database
communicates with the database
have to set database credentials


Autowiring

its annotation driven wiring as opposed to class or config wiring




view rendering syntax of react

component - encapsulated piece of a web page






## Spring Data
- is a Spring Project 
- Spring Data provides Abstractions/interfaces you can use based on the type of database (relational or non-relational)


### Spring Data Interface Hierarchy

This is the interface hierarchy for Spring Data’s interfaces used to create your DAO classes

 - `Repository Interface`
    - base class for all the repositories providing access to databases

- `CrudRepository Interface`
    -  extends Repository
    - it provides CRUD operations irrespective of databases
- ... many other

- `JpaRepository`
    - extends several interface
    - contains most of the basic DAO methods you’ll want to use.
- Your Custom Interface
    - all our DAOs extend JpaRepository


## Spring Data JPA (Java Persistent API) 
- is a Spring Data module
- works with relational databases
- defined in the `javax.persistence` package
- uses the `EntityManager Interface` to do CRUD operations in the database
- has standardized annotations to map our Java models to Database tables
- uses `JDBC` under the hood
- abstract away from the `Hibernate` framework
- uses ORM framework

### Advanteges over JDBC
- simpler
-  easier to change our database dialect, we just change the config file *application.properties*
- converts the ResultSet automatically to POJOs
- no need to know table specific knowledge (table and column names)
- needs  MUCH less lines of connection code and DAO code



## Entity Mapping

`Entity mapping` means mapping our Java Classes into DB ENTITIES.


### Map a class to a table
`@Entity`
- indicates that the Class is meant to be mapped to a DB table 

`@Table` 
- used for setting table options such as the name of the table in the database 

- doesn’t actually make a class a table (@Entity does that)

### Mapping Table Columns
`@Column` 
- Hibernate will turn all of a Class’s field in DB columns by default
- BUT using the annotation lets us set things such as column name, or constraints like not null, and unique.   


### Mapping Primary Keys
The 2 below would define an autogenerated primary key:

`@Id` - Declares a variable as a primary key in a table 

`@GeneratedValue`
- gives you control over the options for how Hibernate will auto-generate your primary key 
```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private int gameId;
```
 
### Maping Relationships 

`@ManyToOne`/`@OneToMany`/`@ManyToMany` 
- define the relationship between our model classes in Java. (Which, as we know, map to tables in our DB.) 

- the relationship is defined from the perspective of the Class in which the annotation sits. 
- the field on the “Many” side would have @ManyToOne
- field on the “One” side would have @OneToMany
- enough to annotate just the @ManyToOne side

 
Examples:

```java
// MANY TO ONE
// mapping one-to-many relationship from the many side
@ManyToOne(fetch = FetchType.EAGER, cascade = CASCADE.ALL)
// name of field in the table on the one side
@JoinColumn(name = userId)
// name of the field here on the many side
private User user;

//___________________________

// MANY TO MANY
@ManyToMany(fetch = FetchType.LAZY, cascade = cascadeType.ALL)
@JoinTable(name = "user_games",
    joinColumns = @JoinColumn(name = "user_id"),
    inverseJoinColumns = @joinColumn(name = "game_id"))
private Set<Game> games;
)

```


- `@JoinColumn` 
    - specifies a column to establish the relationship on
    - Primary Key in the other table usually 

- `fetch`
    - determines when the related objects are called from the database 
    - `EAGER`: immediately 
    - `LAZY`: when they are needed
- `cascade`T
    - specifies the cascading on the database when removing/updating items
    - this is how we maintain referential integrity 


## JPA Transactions

Spring Data JPA provides Spring provides us with the default code that is required to start the transaction, commit, or roll back a transaction. 

### How to use
`@Transactional`
- if using Spring Boot
- for a class or method or interface

`@EnableTransactionManagement`
- if using Spring withoug Spring Boot
- for class

### Example
```java
public class AssociateService {


    // @Transactional Indicates that a method should be treated as a transaction
    @Transactional
    public Long registerAssociate(Associate associate) {
        // inserts the Associate into the database and retrieves the autogenerated id
        // AssociateDao.save(associate);
        return id;
    }
}
```

### Transaction Propagation

Propagation defines our business logic transaction limit. 
- Spring can start and pause a transaction according to our propagation setting. 
- Spring will call the `TransactionManager::getTransaction` to create a transaction according to the propagation.
- Transaction propagation is REQUIRED by default. If an already transaction exists then it will mark as a save point.

#### Propagation Types
- REQUIRED  
    - default behavior.
    - join an active transaction or to start a new one

- SUPPORTS
    - join an active transaction if one exists
    - this method will be executed without a transactional context
- MANDATORY
    - join an active transaction if one exists or to throw an Exception if the method gets called without an active transaction
- NEVER
    - throw an Exception if the method gets called in the context of an active transaction.

- NOT_SUPPORTED
    - pauses an active transaction and executes the method without any transactional context

- REQUIRES_NEW
    - start a new transaction for the method always
    - if the method gets called with an active transaction. that transaction gets suspended until this method got executed.

- NESTED
    - start a new transaction
    -  if it gets called with an active transaction, Spring sets a savepoint and rolls back to that savepoint if an Exception occurs.


Set it by:
`   @Transactional(propagation = Propagation.REQUIRES_NEW)`
```java
@Service
public class AssociateService {
 
    private AssociateRepository associateRepository;
 
    public AssociateService(AssociateRepository associateRepository) {
        this.associateRepository = associateRepository;
    }
 
 
    public void updateAssociateNameTransaction() {
        Associate associate = associateRepository.findById(10).get();
        associate.setName("name");
    }
}
```


### Writing SQL queris

`JPQL` 
- Java Persistence Query Language
- Spring Data provides multiple ways to create and execute a query, and JPQL is one of these.
- uses `@Query` annotation

```java
@Query("SELECT COUNT(*) FROM Person p")
long getPersonCount();


// also, we can use named parameters:
@Query("FROM Person p WHERE p.name = :name")
Person findByName(@Param("name") String name);


// besides, we can use native SQL queries, if we set the native query argument to true

@Query(value = "SELECT AVG(p.age) FROM person p", nativeQuery = true)
int getAverageAge();
```


### JPA Annotations
 

 





## Spring Data JPA Questions 

>What is the JPA? What does it let us do? 

>What are some annotations we use from JPA? Where do we use them? 

>What does ORM stand for? 

>What benefits does Spring Data provide? 

>What is the interface hierarchy? 

>Which interface do we implement to make our custom DAOs? 

>We can’t instantiate interfaces... how do we use the methods in our custom DAOs? 

>Know the Spring Data annotations 

>Know @Transactional annotation and what a transaction is. 

>Look into the transaction propagation strategies in revpro 

>Look at the ACID properties, memorize the main rule for each property.  

 

