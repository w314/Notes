
spring, java, spring data, spring data jpa


# Spring Data JPA (Java Persistence API)  


## Spring Data
- is a Spring Project 
- Spring Data provides Abstractions/interfaces you can use based on the type of database (relational or non-relational)


### Spring Data Interface Hierarchy

This is the interface hierarchy for Spring Data’s interfaces used to create your DAO classes

 - `Repository Interface`
    - base class for all the repositories providing access to databases

- `CrudRepository Interface`
    -  extends Repository
    - it provides CRUD operations irrespective of databases
- ... many other

- `JpaRepository`
    - extends several interface
    - contains most of the basic DAO methods you’ll want to use.
- Your Custom Interface
    - all our DAOs extend JpaRepository


## Spring Data JPA (Java Persistent API) 
- is a Spring Data module
- works with relational databases
- defined in the `javax.persistence` package
- uses the `EntityManager Interface` to do CRUD operations in the database
- has standardized annotations to map our Java models to Database tables
- uses `JDBC` under the hood
- abstract away from the `Hibernate` framework
- uses ORM framework

### Advanteges over JDBC
- simpler
-  easier to change our database dialect, we just change the config file *application.properties*
- converts the ResultSet automatically to POJOs
- no need to know table specific knowledge (table and column names)
- needs  MUCH less lines of connection code and DAO code


### JPA Annotations

#### Fundamental JPA Annotations
(Definitely on QC) 

- used for entity mapping/configuration in our Java Classes
- `Entity mapping` means mapping our Java Classes into DB ENTITIES.


##### Mapping Tables

`@Entity`
- indicates that the Class is meant to be mapped to a DB table 

`@Table` 
- used for setting table options such as the name of the table in the database 

- doesn’t actually make a class a table (@Entity does that)

##### Mapping Table Columns
`@Column` 
- Hibernate will turn all of a Class’s field in DB columns by default
- BUT using the annotation lets us set things such as column name, or constraints like not null, and unique.   


##### Mapping Primary Keys
The 2 below would define an autogenerated primary key:

`@Id` - Declares a variable as a primary key in a table 

`@GeneratedValue`
- gives you control over the options for how Hibernate will auto-generate your primary key 
```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private int gameId;
```
 
#### JPA Relationship Annotations 

`@ManyToOne`/`@OneToMany`/`@ManyToMany` 
- define the relationship between our model classes in Java. (Which, as we know, map to tables in our DB.) 

The relationship is defined from the perspective of the Class in which the annotation sits. 
- the field on the “Many” side would have @ManyToOne
- field on the “One” side would have @OneToMany
- enough to annotate just the @ManyToOne side

In these relationship annotations, we can specify a few attributes, like CascadeType and FetchType (read below) 

@JoinColumn - Specifies a column to establish the relationship on. Just like we do normally, this is usually a Foreign Key pointing to the Primary Key of the table being referred to.  

CascadeType specifies the cascading on the database when removing/updating items. This is how we maintain referential integrity in hibernate. 

I tend to always use CascadeType.ALL when possible, making all typical Cascade operations occur when needed.  

FetchType determines if the related objects are called from the database immediately (EAGER) or if called, waits until they are needed (LAZY).  

I tend to always use EAGER, more memory intensive, but less error prone. 

 

 

 

Implementing @ManyToMany requires specifying a @JoinTable annotation to determine which table we’re linking to create a Many to Many relationship (This is how we make JOIN TABLES in Spring Data) 

Feel free to investigate, but I typically just use @ManyToOne and @OneToMany together to accomplish the same functionality as @ManyToMany. 

 

 

Other Spring Data Annotations 

 

Spring Data has even more annotations that abstract away the code required for data storage, allowing us to focus more on the business logic. The following is a list and brief explanation of some common Spring Data annotations, which allow us to configure how the queries execute. Usually, defaults are fine, and we won’t need to mess with these. 

These annotations will mostly stay in the DAOs and models 

These are all cAsE sEnSiTiVe!!!  

 

Annotation 

Purpose 
## JPA Transactions

Spring Data JPA provides Spring provides us with the default code that is required to start the transaction, commit, or roll back a transaction. 

### How to use
`@Transactional`
- if using Spring Boot
- for a class or method or interface

`@EnableTransactionManagement`
- if using Spring withoug Spring Boot
- for class

### Example
```java
public class AssociateService {


    // @Transactional Indicates that a method should be treated as a transaction
    @Transactional
    public Long registerAssociate(Associate associate) {
        // inserts the Associate into the database and retrieves the autogenerated id
        // AssociateDao.save(associate);
        return id;
    }
}
```

### Transaction Propagation

Propagation defines our business logic transaction limit. 
- Spring can start and pause a transaction according to our propagation setting. 
- Spring will call the `TransactionManager::getTransaction` to create a transaction according to the propagation.
- Transaction propagation is REQUIRED by default. If an already transaction exists then it will mark as a save point.

#### Propagation Types
- REQUIRED  
    - default behavior.
    - join an active transaction or to start a new one

- SUPPORTS
    - join an active transaction if one exists
    - this method will be executed without a transactional context
- MANDATORY
    - join an active transaction if one exists or to throw an Exception if the method gets called without an active transaction
- NEVER
    - throw an Exception if the method gets called in the context of an active transaction.

- NOT_SUPPORTED
    - pauses an active transaction and executes the method without any transactional context

- REQUIRES_NEW
    - start a new transaction for the method always
    - if the method gets called with an active transaction. that transaction gets suspended until this method got executed.

- NESTED
    - start a new transaction
    -  if it gets called with an active transaction, Spring sets a savepoint and rolls back to that savepoint if an Exception occurs.


Set it by:
`   @Transactional(propagation = Propagation.REQUIRES_NEW)`
```java
@Service
public class AssociateService {
 
    private AssociateRepository associateRepository;
 
    public AssociateService(AssociateRepository associateRepository) {
        this.associateRepository = associateRepository;
    }
 
 
    public void updateAssociateNameTransaction() {
        Associate associate = associateRepository.findById(10).get();
        associate.setName("name");
    }
}
```


## JPA Annotations
### @Transactional 

Indicates that a method should be treated as a transaction. See the Transaction notes below, you’ll often need to use this with updates/deletes. 

@NoRepositoryBean 

Creates an Interface that provides common methods for child repositories. Like making your own version of JpaRepository. Not intended to be used directly for data operations. 

@query & @param 

@query can be used to create your own custom queries with more direct SQL-esque syntax. @param lets you pass parameters to queries defined with @query 

@transient 

Marks a field as transient, to be ignored by the data store. Transient = not persisted to DB.   

 

 

 


■ “EntityManager is the interface that lets us query/manipulate our database from our Java server” -Good QC line

Implementation

- 


JPA is where we get the annotations that map our model classes to DB tables. 

- defined in the `javax.persistence` package
- uses annotations from the JPA to directly map our Java models to Database tables. (So our DB tables get created by our Java models!)
- uses the `EntityManager Interface` to create, read, update and delete (crud) DB entities (tables) and their data in the database. 


`EntityManager Interface`
 - the interface that lets us query/manipulate our database from our Java server (QC line) 

JPA has standardized annotations that we’ll rely on heavily (e.g. @Entity comes from javax.persistence and indicates that a model class is meant to be a DB table).  

 



 


## Spring Data JPA Questions 

>What is the JPA? What does it let us do? 

>What are some annotations we use from JPA? Where do we use them? 

>What does ORM stand for? 

>What benefits does Spring Data provide? 

>What is the interface hierarchy? 

>Which interface do we implement to make our custom DAOs? 

>We can’t instantiate interfaces... how do we use the methods in our custom DAOs? 

>Know the Spring Data annotations 

>Know @Transactional annotation and what a transaction is. 

>Look into the transaction propagation strategies in revpro 

>Look at the ACID properties, memorize the main rule for each property.  

 

